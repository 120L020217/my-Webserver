block_queue.h：  
1. 阻塞队列默认大小为1000，阻塞队列的数据结构为循环数组。
2. 用生产者消费者模型共享阻塞队列
+ push操作为生产
+ pop操作为消费  
3. 实现多线程安全（多线程访问共享队列中的元素不会乱），通过条件变量和互斥量实现的。

log.h:  
1. 单例模式实现日志系统
+ 私有化构造函数，防止外界访问
+ 静态指针指向唯一实例
+ public静态方法（静态方法才能访问静态变量），提供外界获取实例的途径
+ 双锁检测的单例模式（有缺陷：p = new singleTon();无法保证原子性）
```cpp
static singleTon* p;

static singleTon* getInstance() {
    if (···) {
        ···
        if (···) {
            p = new singleTon();
        }
    }
}
```
+ C11后，使用静态局部变量，指向唯一实例（即本项目用的方法）。新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它，即保证了原子性。在get_instance方法第一次调用时，初始化唯一实例。后续调用get_instance就可以直接返回这个静态局部变量指向的唯一实例。

2. 同步写入的日志系统

3. 异步写入的日志系统
+ 回调函数为什么是static？
    + 因为线程入口函数不能是一个和对象有关的函数（可以通过去掉static看报错得出），static使函数与类有关、与对象无关。
+ 细节处理：异步模式下仍可能同步处理
```cpp
// 即使是异步日志，如果阻塞队列已经满了，仍采用同步方式，防止太多进程睡在阻塞队列上
if (m_is_async && !m_log_queue->full()) {
    m_log_queue->push(log_str);
} else {
    m_mutex.lock();
    fputs(log_str.c_str(), m_fp);
    m_mutex.unlock();
}
```