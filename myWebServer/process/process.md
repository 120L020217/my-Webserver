# 构建一个高性能cpp服务器
## 阶段一：通读《Linux高性能服务器编程》
### 一、TCP/IP协议族
#### 数据链路层：  
ARP协议：依靠广播方式，在本地链路上工作，它的工作任务时建立ip地址和mac地址映射。  
#### 网络层：  
IP协议：IP协议根据数据包的目的地址决定发往下一跳。  
ICMP协议：ICMP协议主要用于监测网络连接。一类是差错报文，回应网络错误，如目标不可达；一类是查询报文，ping就是利用它。  
#### 传输层：  
TCP：  
![avatar](../Resources/0.jpg)
UDP：  
UDP无需保存应用层数据的副本，因为它提供不可靠的服务，数据包发送成功后，UDP内核缓冲区的数据报就被丢弃了。正因为UDP提供不可靠服务，往往上层应用会实现可靠传输，如果需要重传，则应用程序需要重新将用户区的数据拷贝到内核缓冲区。
#### 应用层：  
应用层协议负责应用程序的逻辑，他屏蔽下面几层的实现细节，这部分必须稳定高效，因此他们在**内核中实现**。  
telnet：远程登录协议，本地完成远程任务。  
OSPF：动态路由更新协议。  
DNS：  
应用层协议或程序可能跳过传输层直接使用网络层协议，也可能同时支持TCP和UDP两种传输层协议。  

---  
#### Linux下的一些网络相关命令
抓包  
tcpdump -i eth0 -ent '(dst xxx and src xxx)'  
远程连接主机，同时输出信息
telnet xxx.xx.xx.xx echo  
访问DNS服务器，查询域名ip  
host -t A www.baidu.com
#### Linux下DNS配置相关文件：/etc/resolve.conf
#### socket是操作系统为了向核心态传递数据的系统调用机制
因为数据链路层、网络层、传输层协议都是在内核中实现的，所以操作系统需要实现一组系统调用，是应用程序能访问这些协议提供的服务。  
socket主要实现两个功能：  
+ 将应用程序数据从用户态缓冲区复制到TCP/UDP内核发送缓冲区，以交付内核发送数据。或是反过来从内核读数据。
+ 应用程序可以通过他们修改各层协议的某些头部信息和其他数据结构。比如setsocketopt函数来设置ip数据报在网络上的存活时间。  
### 二、IP协议
#### IP服务的特点：无状态、无连接、不可靠
无状态指不同步状态，IP数据包彼此独立。无连接指通信双方不保存对方信息，所以每次都要声明目的ip源ip。不可靠，即不保证可靠传输，发送失败并不会重传。
### 三、TCP协议
#### TCP协议的流量控制
[指路](https://blog.csdn.net/sinat_30955745/article/details/104848046)

**TCP的socket缓冲区如何接收数据**  
当套接字缓冲区可用空间限制对端窗口大小，TCP套接字缓冲区不可能溢出，因为，因为不允许对端发送超过本段窗口大小的数据。这是TCP的流量控制，如果对端无视TCP的窗口大小而发送超过窗口大小的数据，将丢弃并且不发送ACK。  
**Contrast with UDP**  
对于UDP而言，当接收到的数据报装不进套接字接收缓冲区时，该数据报就会被丢弃。 UDP是没有流量控制的，较快的发送端可以很容易地淹没较慢的接收端，导致接收端的UDP丢 弃数据报。事实上较快的发送端甚至可以淹没本机的网络接口，导致数据报被本机丢弃。  

#### TCP服务特点

**面向链接**  
TCP服务是一对一的，所以基于广播和多播的服务无法使用。广播和多播通常使用无连接服务UDP。  
**字节流服务和数据报服务区别**   
![avatar](../Resources/1.jpg)   
体现在实际编程中是通信双方是否执行相同次数的写、读操作。TCP是字节流服务，发送方执行写操作次数和内核中TCP模块发送TCP报文数没有固定数量关系，接受方执行读操作次数与TCP模块接受TCP报文段个数也没有固定数量关系。这就是字节流概念，数据的发送和接受是没有边界概念的。UDP的应用程序，每次执行一次写操作，UDP模块就封装成一个UDP数据报，接收端需要**及时**对每一个数据报执行读操作，否则就会被丢弃。而且如果应用程序的缓冲区大小不足，数据报还会被截断。  
**可靠传输**  

#### TCP头部

头部选项部分，可能包含的信息：  
+ MSS：通常设置为MTU-40B（20B ip头，20B tcp头），表示最大报文段长度，以防止本机ip数据报就被分片。
+ 接受窗口扩大因子：因为头部中接收窗口大小的字段位数限制，为表示更大的接受窗口，设置接受窗口扩大因子，表示原来的大小左移几位。
+ SACK选项：选择性确认选项。防止已经被接受的数据报，因为之前的数据报接收超时而被重传。

#### TCP状态转移
四次挥手中的第三次挥手，客户端收到服务器的（fin、ack）报文段，不会立刻关闭，而是进入TIME_WAIT状态。有两点原因：  
+ 确保客户端的第四次挥手能被服务器收到，这样服务器才能关闭链接，释放资源。  
+ 保证网络上与这次链接有关的所有报文都消失，（等待两个MSL时间），这样，这个连接被重新启用（只相同的ip地址和端口号）时，上次连接的报文不会干扰。

#### TCP拥塞控制
拥塞控制直接的受控变量时发送端一次向网络连续写入的最大值，即SWND（send window）。连续写入，只收到其中第一个数据的确认之前。因为TCP以报文段发送，所以SWND限定了连续发送报文段的数量。  
慢启动（指数增长，慢启动并不慢）--拥塞避免（线性增长）--拥塞控制（判断出网络拥塞，比如收到三个相同的ACK报文，阈值减半）

### 四、访问Internet上的Web服务器
#### 正向代理和反向代理
正向代理是代理客户，客户对因特网的访问发到正向代理服务器，代理服务器代表客户访问互联网。  
反向代理服务器是代理服务端，客户访问代理服务器，好像是访问真正的服务器。
#### TCP连接建立和断开过程中客户端和服务器状态变化
![avatar](../Resources/2.jpg)

### 五、高级IO API

```cpp
    #include <unistd.h>
    // fd数组用来存放一对文件描述符。pipe是单向管道。
    int pipe(int fd[2]);

    #include <unistd.h>
    // 创建一个指向与原有文件描述符相同文件的文件描述符
    int dup(int file_descriptor);

    #include <sys/uio.h>
    // 将数据从文件描述符读到分散内存块
    ssize_t readv(int fd, const struct iovec* vector, int count);
    // 将数据从分散内存块写到文件描述符
    ssize_t writev(int fd, const struct icvec* vecotr, int count);

    // struct iovec是描述一块内存区的结构体
    // struct ivoc {
    //     void* iov_base; // 起始地址
    //     size_t iov_len; // 长度
    // }

    #include <sys/senfile.h>
    // 在内核中，两个文件描述符直接传递数据（零拷贝）
    // 这是一个专门为网络上传输文件设计的函数，in_fd必须指向真实的文件，不能是pipe或者socket，out_fd必须是socket。
    ssize_t senfile(int out_fd, int in_fd, off_t* offset, size_t count);

    #include <sys/mmap.h>
    // 用来申请一段内存，可以用作进程间通讯的共享内存，也可以把文件之间映射到这个内存
    void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);
    int munmap(void* start, size_t length);

    #include <fcntl.h>
    // 两个文件描述符之间移动数据（零拷贝）
    ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);

    #include <fcntl.h>
    // 和splice类似，只不过来你两个文件描述符都是管道
    ssize_t tee(int fd_in, int fd_out, size_t len, unsighed int flags);

    #include <fcntl.h>
    // 控制文件描述符的函数
    int fcntl(int fd, int cmd,...);
    
```

#### 零拷贝
直接在内核中传递数据，从而避免用户缓冲区和内核缓冲区之间的数据拷贝，效率更高，称为零拷贝。

当谈论指向socket的文件描述符时，对于网络套接字，它实际上指向了内核中的套接字数据结构。

这个套接字数据结构中包含了许多信息，其中就包括了套接字的接收缓冲区和发送缓冲区。这两个缓冲区是用于存储接收和发送的数据的，它们在套接字的生命周期内被动态地管理。当你通过文件描述符进行读取或写入操作时，实际上是在操作这些缓冲区。

### 六、高性能服务器程序框架

## 阶段二 牛客网webserver课程
### 一、Linux系统编程入门
#### 静态库的制作和使用

```
// 编译要打包的文件（-c选项不链接）
gcc -c xxx.c xxx.c
// 打包文件
ar rcs libxxx.a xxx.o xxx.o
// 移动生成的静态库到指定文件夹
mv libxxx.a ../lib/
// 编译新文件，使用之前打包的库
gcc main.c -o app -L ../lib/ -l xxx
```

#### 动态库的制作和使用
```
// 编译得到.o文件（需要位置无关代码-fpic）
gcc -c -fpic xxx.c xxx.c
// gcc得到动态库
gcc -shared xxx.o xxx.o -o libxxx.so
// gcc链接时，动态库的代码不会打包到可执行程序中
gcc main.c -o app -L ../lib -l xxx

// 检查可执行文件的动态库依赖
ldd xxx
<!-- 
    在使用 ldd 命令查看共享库依赖关系时，它实际上只是读取可执行文件（或共享库）的头部信息，其中包含了关于共享库的位置信息。这些位置信息包括虚拟地址的基址。
    在可执行文件中，共享库的路径和名称以及一些其他信息（如加载时的选项）被记录在头部。这使得动态链接器在加载时能够找到和加载相应的共享库。
    这里的虚拟地址是在编译和链接时预定的地址，而不是在程序运行时分配的实际地址。当程序运行时，操作系统的动态链接器会将共享库加载到进程的虚拟地址空间中，而不一定是预定的地址。虚拟地址的具体分配是由操作系统进行的，确保每个进程有独立的地址空间。
    所以，即使动态库还没有被加载，ldd 命令也能显示出预定的虚拟地址。这样做的目的是为了在构建可执行文件时，让编译器和链接器知道共享库的位置，以便在程序运行时正确地加载这些库。 
-->
```

#### 如何定位共享库文件
当系统加载可执行代码的时候，能够知道其多依赖的库的名字，但还需要知道绝对路径。此时需要系统的动态载入器（对于elf格式的可执行程序，是ld-linux.so）来获取绝对路径。它先后搜索elf文件的DT_RPATH段--》环境变量LD_LIBRART_PATH--》/etc/ld.so.cache文件列表--》/lib/, /usr/lib 找到库文件后载入内存。

在加载动态库时（程序开始运行时），动态链接器会解析库中的符号引用，将它们映射到程序的地址空间，并解决任何必要的**重定位**。这确保了程序可以正确调用和访问动态库中的函数和数据。

#### makefile
**一些预定义变量**  
CC （default）gcc  
CXX （default）g++  
AR (default) ar  
**\$**  
\$(变量名)：取变量值  
\$@: 取对象值  
\$<: 取第一个依赖文件  
\$^: 取所有依赖文件  
**\%**  
\%: 模式匹配，匹配一个字符串（第二次出现时，表示第一个%匹配的字符串）  
**函数**  
\$(wildcard PATTERN): 获取符合PATTERN指定类型的文件

#### GDB
```
// -g 在可执行文件中插入源代码信息，比如可执行文件中的第几条机器指令对应源代码的第几行
// -Wall 显示所有warning
gcc -g -Wall program.c -o program
```

#### FILE文件与fd文件描述符
FILE文件指针中有三个部分:  
+ 文件描述符  
+ 指向当前文件读写指针的位置  
+ 指向io缓冲区起始位置的指针（虚拟内存地址）  

io缓冲区起到了类似cache的作用，在内存中的一块空间，减少与磁盘io次数。  

文件描述符是文件描述符表的索引，文件描述符表保存在进程控制块中（一个进程中可以打开多个文件），大小为1kb。文件描述符表的每一个条目中保存文件操作函数表的指针,文件状态,文件当前偏移,文件被引用次数.
![avatar](../Resources/3.png)
文件描述符0、1、2三个分别对应标准输入文件、标准输出文件、标准错误文件，默认是打开的。每打开一个文件，占用一个文件描述符，而且是空闲的最小文件描述符。  
磁盘是按块存储的，知道盘块号就能找到文件在磁盘中的保存位置。盘块号有索引块inode保存。而从文件描述符表中能找到inode的位置。

### 二、Linux多进程开发
#### 进程的状态转换
![avatar](../Resources/4.png)
```
// 查看进程状态
ps aux
ps ajx
// 显示进程动态
top
```

#### 父子进程虚拟地址使用情况
子进程的虚拟空间是拷贝父进程的，除了各自内核空间中PCB中的pid, ppid不一样, **信号集不一样**，其他都是一样的。在实际的物理内存中，采用写时拷贝技术（读时共享），避免重复资源拷贝造成的资源浪费。  
fork之后的父子进程共享打开的文件，他们**共享**文件描述符表, 文件被引用次数+1.

#### GDB调试多进程
```
// 设置gdb跟踪父进程还是子进程(默认父进程)
set follow-fork-mode 
// 设置fork时,是否脱离gdb跟踪(默认开启)
set detach-on-fork
// 查看当前跟踪的进程(*表示当前调试的进程)
info inferiors
// 切换当前调试的进程
inferior [num]
// 使某进程脱离GDB跟踪
detach inferiors [num]
```

#### exec函数族
exec就是在调用进程内部执行一个可执行文件。exec函数族执行成功不会返回，因为调用进程的实体，包括代码段数据段和堆栈等已经被新的内容取代，只留下进程id等信息保持原样，类似金蝉脱壳。  

#### 程序退出
```cpp
// status是进程退出状态信息,父进程回收子进程资源时可以获取
// 这两个函数都会系统调用,进内核退出程序.
// 程序结束前刷新io缓冲区
#include <stdlib.h>
void exit(int status);
// 程序结束前不会刷新io缓冲区
#include <unistd.h>
void _exit(int status);
```

#### 僵尸进程和孤儿进程区别
孤儿进程是父进程退出后,子进程仍然没有结束,子进程成为孤儿进程,由操作系统接管.孤儿进程对系统没有危害.  
僵尸进程是子进程死后,父进程没有回收资源,子进程内核区的数据没人释放,一直占着内存,成为了僵尸进程.  

#### waitpid()

#### 进程间通信IPC技术
+ 管道
+ 信号
+ 内存映射
+ 内存共享

#### 中断
中断有两种方式，一是软件主动发起**中断指令**，二是硬件发送**中断信号**。他们都会使程序进入内核态。  
中断指令 (int 指令)：  
用途： 在汇编语言中，int 指令通常用于触发软中断，引发中断处理例程的执行。软中断是由软件生成的，例如，通过在汇编或高级语言中使用 int 指令来请求操作系统执行某个服务。  
实例： 在 x86 汇编中，通过 int 0x80 指令可以触发 Linux 的系统调用，请求操作系统执行特定的功能，如文件 I/O、进程控制等。  
中断信号：  
用途： 中断信号是一种由操作系统或硬件发出的异步通知，用于表示发生了特定事件。这些事件可能包括硬件错误、进程异常、用户请求等。中断信号用于通知操作系统或进程在发生某些事件时执行相应的处理。  
实例： 在类 Unix 操作系统中，有许多不同的中断信号，例如 SIGINT 用于中断进程，SIGSEGV 用于表示段错误等。这些信号可以通过系统调用或硬件事件触发。  

*中断指令是如何令内核接管程序的呢，请详细描述一下这个过程*（哈工大操作系统李志军，第一部分）  
在 x86 架构下，通过中断指令（int 指令）触发中断，使得操作系统内核接管程序的过程涉及到硬件和软件协同工作。以下是通常的步骤：  
**设置中断向量表**： 操作系统内核在启动时会设置中断向量表（Interrupt Vector Table，IVT）。IVT 是一个包含中断服务例程地址的表，其中每个表项对应一个中断号。IVT 通常位于内存的固定位置（例如，0x0000:0x0000），并且操作系统负责填充其中的内容。  
**触发中断**： 程序通过 int 指令触发中断。int 指令的操作数是中断号，即要触发的中断的编号。例如，int 0x80 是 Linux 中用于触发系统调用的典型例子。执行 int 指令会导致 CPU 转移到中断服务例程的地址。  
**保护现场**： 在进入中断服务例程之前，CPU 会自动保存当前执行上下文的信息，例如程序计数器、标志寄存器、通用寄存器等。这个过程通常称为“保护现场”或“上下文保存”。  
**查找中断服务例程**： CPU 根据中断号在 IVT 中查找相应的中断服务例程的地址。中断服务例程是内核为处理特定中断而编写的代码。（同时改变访问权限CPL，使程序进入内核态）  
**执行中断服务例程**： CPU 转移到中断服务例程的起始地址，并开始执行相应的中断处理代码。中断服务例程负责处理中断引起的事件，可能包括**系统调用**、硬件中断、异常处理等。  
**执行中断处理代码**： 中断服务例程中的代码会执行与中断相关的操作，完成特定的任务。例如，在系统调用中，中断服务例程会根据中断号执行相应的系统调用，然后返回结果。 
**恢复现场**： 在中断服务例程执行完毕后，CPU 会自动从保存的上下文中恢复执行现场。这个过程通常称为“恢复现场”。  
**返回到用户程序**： 最终，CPU 返回到用户程序，并继续执行用户程序的指令。  
这整个过程中，关键的是中断向量表的设置和中断服务例程的编写。中断服务例程由操作系统内核编写，用于处理不同类型的中断和异常。这种机制使得操作系统能够响应硬件中断、处理用户程序的系统调用请求等。  

*中断信号是如何令内核接管程序的呢，请详细描述一下这个过程*（csapp第八章信号）
中断信号是一种异步事件通知机制，用于通知操作系统或进程发生了特定的事件。中断信号通常由硬件或操作系统生成，并通过软件机制传递给相应的进程。以下是中断信号使内核接管程序的一般过程：  
**中断信号的生成**： 中断信号可以由硬件事件（如时钟中断、I/O 中断）或由操作系统生成（如段错误、用户键入中断字符 Ctrl+C）而产生。  
**信号传递给进程**： 当中断信号产生时，操作系统会将信号传递给受影响的进程。这是通过将信号信息放入进程的信号队列中或通过直接调用信号处理函数（如果已经注册了）来完成的。  
**选择信号处理函数**： 如果进程注册了特定的信号处理函数，操作系统会调用该函数以响应信号。否则，进程将采用默认的信号处理方式。  
**执行信号处理函数**： 信号处理函数是由用户编写的函数，用于定义在接收到特定信号时应该执行的操作。这个函数通常被称为“信号处理程序”或“信号处理器”。  
**默认行为或自定义操作**： 如果没有注册信号处理函数，操作系统会采用默认的信号处理行为，这可能包括终止进程、忽略信号、停止进程等。如果有信号处理函数，它将执行用户定义的操作。  
**恢复执行**： 一旦信号处理函数执行完毕，控制权将返回到原始的程序执行点，或者进程可能根据信号处理的性质而采取不同的行为。  
需要注意的是，中断信号的处理方式和信号处理函数的执行是**异步**的，它们可以在进程的任何时刻发生。这使得操作系统能够在发生特定事件时通知进程，而无需等待进程显式地轮询或查询事件。  
总体而言，中断信号机制允许操作系统或其他进程通知目标进程发生了某些特定事件，提供了一种异步的、事件驱动的编程模型。  

### 三、Linux多线程开发
#### 查看指定进程的线程号
```
ps -Lf pid
```
TCB通常存储在内核的线程表（Thread Table）中。线程表是操作系统内核用于追踪和管理所有线程的数据结构。每个线程都有对应的TCB，而线程表中的每一项都指向一个线程的TCB。  
当操作系统进行线程切换时，它会使用线程表中的信息来保存当前线程的状态，并加载下一个线程的状态。这样可以确保在多线程环境中的合理切换和调度。  
需要注意的是，TCB等线程信息通常是由操作系统内核来管理和维护的，而用户程序无法直接访问或修改它们。  

#### 线程和进程虚拟地址空间
线程会共享相同的虚拟地址空间，这包括数据段、堆区域，但每个线程通常都有自己的栈空间。每个线程都拥有独立的栈，用于存储局部变量、函数调用信息以及线程的执行上下文。
![avatar](../Resources/5.png)

#### 内核级线程相关的API
```cpp
 #include <pthread.h>
 /* 内核级线程
    thread:无符长整型,保存创建的线程id
    attr:设置线程属性,一半为NULL
    start_routine:函数指针,指向线程执行流
    arg:上一个参数的传参

    return:成功返回0,失败返回errornum.这个错误号与errno不一样
    获取错误号信息:char* strerror(int errornum)
    
    编译时指定动态库位置 -lpthread*/
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                    void *(*start_routine) (void *), void *arg);

/**
 * 哪个线程中调用,终止哪个线程
 * retval:作为返回参数,可以被pthread_join获取
 */
void pthread_exit(void *retval);

// 返回当前线程id
pthread_t pthread_self();
// 比较线程id
int pthread_equal(pthread_t t1, pthread_t t2)

/**
 * 和一个已终止的线程链接,以回收子线程资源
 * 阻塞函数,调用一次只能回收一个子线程
 * thread:要回收线程的id
 * retval:子线程退出时的返回值
 * 
 * retval是二级指针的原因:
 * pthread_exit返回一个指针,指向他想返回的值,在主线程中我们就需要一个指针来接这个返回的指针.然而,如果传入指针的话,只是形参接住了这个指针,实参不会有变化.所以要用二级指针确保实参接到这个二级指针.
 */
int pthread_join(pthread_t thread, void** retval);

/**
 * 分离一个线程，被分离的线程终止，自动释放资源给系统
 * 一个线程不能多次分离
 * 不能连接已分离的线程
 */ 
int pthread_detach(pthread_t thread);

/**
 * 取消某个线程，可以终止某个线程运行。但不是立刻终止，而是线程走到一个去小店，线程才会终止
 * 取消点：系统规定的一组系统调用。粗略地认为是用户态转内核态的点
 */ 
int pthread_cancel(pthread_t thread);

// 初始化线程属性的资源
int pthread_attr_init(pthread_attr_t *attr);
// 释放线程属性资源
int pthread_attr_destroy(pthread_attr_t *attr);
// get线程分离状态属性
int pthread_attr_setdetachstate(pthread_attr_t * attr);
// set 线程分离状态属性
int pthread_attr_getdetachstate(pthread_attr_t* attr);
```

#### 线程同步
**临界区**：访问某一个共享资源片段时，这段代码应为原子操作。也就是同时访问同一共享资源的其他线程不应中断该片段的执行。
线程同步的实现方式：  
1）互斥量（锁）  
相当于一个二进制信号量（只有0和1的信号量）。
2）条件变量  
3）信号量  
### 四、IO多路复用
IO多路复用技术能**同时监听多个文件描述符**，能够提高程序性能。Linux下实现IO多路复用的三个系统调用select、poll、epoll。
+ select

+ poll
+ epoll